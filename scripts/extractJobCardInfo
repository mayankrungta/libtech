#! /usr/bin/env python

import os
import sys
import logging
import MySQLdb
import csv

fileDir=os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, fileDir+'/../includes/')
from settings_default import dbhost,dbuser,dbpasswd,sid,token


#######################
# Global Declarations
#######################

delay = 2
timeout = 10
browser="Firefox"
logFile = __file__+'.log'
logLevel = logging.ERROR
logFormat = '%(asctime)s:[%(name)s|%(module)s|%(funcName)s|%(lineno)s|%(levelname)s]: %(message)s' #  %(asctime)s %(module)s:%(lineno)s %(funcName)s %(message)s"

#############
# Functions
#############

'''
def logInitialize():
  import logging
  logging.basicConfig(filename=logFile, level=logLevel, format=logFormat) # Mynk
  logging.basicConfig(
    filename = fileName,
    format = "%(levelname) -10s %(asctime)s %(module)s:%(lineno)s %(funcName)s %(message)s",
    level = logging.DEBUG
)
'''

def loggerFetch(level=None):
  logger = logging.getLogger(__name__)

  if level:
    numeric_level = getattr(logging, level.upper(), None)
    if not isinstance(numeric_level, int):
      raise ValueError('Invalid log level: %s' % level)
    else:
      logger.setLevel(numeric_level)
  else:
    logger.setLevel(logLevel)

  # create console handler and set level to debug
  ch = logging.StreamHandler()
  ch.setLevel(logging.DEBUG)    # Mynk ???

  # create formatter e.g - FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
  formatter = logging.Formatter(logFormat)

  # add formatter to ch
  ch.setFormatter(formatter)

  # add ch to logger
  logger.addHandler(ch)

  return logger

def loggerTest(logger):
  logger.debug('debug message')
  logger.info('info message')
  logger.warn('warn message')
  logger.error('error message')
  logger.critical('critical message')
    

def argsFetch():
  '''
  Paser for the argument list that returns the args list
  '''
  import argparse

  parser = argparse.ArgumentParser(description='Jobcard script for crawling, downloading & parsing')
  parser.add_argument('-v', '--visible', help='Make the browser visible', required=False, action='store_const', const=1)
  parser.add_argument('-l', '--log-level', help='Log level defining verbosity', required=False)
  parser.add_argument('-t', '--timeout', help='Time to wait before a page loads', required=False)
  parser.add_argument('-b', '--browser', help='Specify the browser to test with', required=False)
  parser.add_argument('-u', '--url', help='Specify the url to crawl', required=False)
  #  parser.add_argument('-j', '--jobcard-number', help='Specify the jobcard no to fetch', required=True)
  #  parser.add_argument('-m', '--mobile-number', help='Specify the mobile number', required=True)
  #  parser.add_argument('-i', '--missed-call-id', help='Specify the ID of missed call', required=True)
  parser.add_argument('-c', '--csv', help='Specify CSV with jobcards', required=False)
  parser.add_argument('-o', '--outfile', help='Specify the outfile if different from input file', required=False)
  parser.add_argument('-q', '--query', help='Query to specify the workset, E.g ... where id=147', required=False)

  args = vars(parser.parse_args())
  return args

def parserFinalize(parser):
  parser.close()

def dbInitialize(host="localhost", user="root", passwd="root123", db="libtech", charset=None):
  '''
  Connect to MySQL Database
  '''
  db = MySQLdb.connect(host=host, user=user, passwd=passwd, db=db, charset=charset)
  db.autocommit(True)
  return db;

def dbFinalize(db):
  db.close()


def fetchJobcardInfo(logger, cur, row, outfile):
  '''
  Fetch the jobcard details
  '''
  logger.info("Row[%s]" % row)

  jobcard = row[0]
  logger.info("Processing jobcard[%s]" % jobcard)

  if jobcard == "" or jobcard.find('/') != 17:
    return

  query = 'select headOfFamily from jobcardRegister where jobcard="' + jobcard + '"'
  logger.info("query[%s]" % query)
  cur.execute(query)
  head = cur.fetchall()[0][0]
  logger.info("HeadOfFamily[%s]" % head)

  query = 'select applicantName, accountNo from jobcardDetails where jobcard="' + jobcard + '"'
  logger.info("query[%s]" % query)
  cur.execute(query)
  names = cur.fetchall()
  #print names    
  logger.debug("Names[%s]" % str(names))

  name_list = ''
  for name in names:
    print name
    name_list += name[0].strip() + "(" + name[1] + ") "
  logger.info("NamesList[%s]" % name_list)

  row += [ head, name_list ]
  print row

  import codecs

  with codecs.open(outfile, 'a', "utf-8") as out_handle:
    out_handle.write(','.join(row) + '\n')

    logger.info("Written file [%s]" % outfile)
    logger.debug("File content [%s]" % ','.join(row))


def processInput(logger, csvfile=None, outfile=None, query=None):
  '''
  Process any missed calls in the libtech DB
  '''
  db = dbInitialize(host=dbhost, user=dbuser, passwd=dbpasswd, db="surguja", charset="utf8")
  cur = db.cursor()
  cur.execute("SET NAMES utf8")

  logger.info("BEGIN PROCESSING...")


  if csvfile == None:
    csvfile = '/tmp/jc.csv'
    
  if outfile == None:
    outfile = '/tmp/z.csv'

  with open(csvfile, 'rb') as csv_handle:
    jobcards = csv.reader(csv_handle, delimiter=',')
    
    for row in jobcards:
      fetchJobcardInfo(logger, cur, row, outfile)
      
  dbFinalize(db)
  logger.info("...END PROCESSING")
  

def main():
  args = argsFetch()
  logger = loggerFetch(args.get('log_level'))
  logger.info('args: %s', str(args))

  processInput(logger, args['csv'], args['outfile'], args['query'])

  exit(0)

if __name__ == '__main__':
  main()
